<!-- @author     Merder Kim <hoxnox@gmail.com> 
<!-- @date       2012-06-01 12:32:54 -->
<!-- @copyright  Merder Kim  -->
<!-- Проект распространяется под лицензией BSD -->

О проекте
=========

_Cursord_ представляет собой сервер, последовательно выдающий данные из какого-либо *источника* в
ответ на запросы клиентов.

Источником может выступать файл, запрос к базе данных или какой-то специфичный генератор. Источник
определяется параметром "type". Каждый тип курсора имеет свои аргументы:

* file - имя файла
* odbc - название источника данных и SQL запрос
* generator - генератор и его аргументы. Все генераторы имеют как минимум 2 аргумента: init -
  начальное значение и repeat -  повторять с начала при достижении конца (по-умолчанию выключена).

Реализованы следующие генераторы:

* integers: 1, 2, 3, ...
* hosts: 1.0.0.0, 1.0.0.1, ...
* hosts:port 1.0.0.0:1, 1.0.0.1:1, ...

:note: Если в качестве параметра генератору host или host:port передать в качестве начального
       аргумента IPv6 адрес, он будет работать с IPv6.

Сервер разработан с целью упрощения оганизации распределённой обработки и чаще всего выступает в
качестве источника задач. Если говорить в рамках модели Consumer-Producer, cursord - это Producer с
встроенной очередью сообщений.

Инструмент простой и понятный.

Пример использования:

Допустим имеется БД в которой хранятся условия для решения задач. Запускаем
курсор следующим образом:

	./cursord  -f odbc -a "dsn=ODBCName,query='SELECT some_data,
	some_addition_data FROM one_table, second_table WHERE some complex expression'"

Теперь у нас имеется сервис, который по запросу `GET` выдаст *очередную* строку, соответствующую
запросу, содержащую условия для решения задачи. Таким образом мы можем запустить N отдельных процессов,
получающих условия и решающих задачи. Как следствие мы может управлять процессом решения задач и
получать данные об общем ходе решения. Рассмотрим глупый, но понятный пример. Допустим имеется
таблица имен и адресов пользователей:

	MAILS

	username mail
	======== ================
	John     john@example.com
	Peter    peter@example.com
	Harry    harry@example.com
	Thomas   thomas@example.com

Мы бы хотели запустить 3 машины, которые посылали бы "Hello, %username%!" каждому пользователю.
Причём с минуты на минуту у нас появиться еще некоторое количество серверов, которые можно будет
подключить к этому процессу. Все просто, запускаем курсор на какой-то машине

	./cursord -t odbc -a "credentials=~/.credentials,query='SELECT username, mail FROM mails'"

А на каждом из серверов запускаем примерно такую программу (псевдокод):

	cursor_host = connect(cursor-host.com);
	response = cursor_host.get();
	data = split(response, 0x1E);
	sendmail(data[0], "Hello, " + data[1]+ "!");

Чтобы проверить скорость рассылки, посылаем курсору запрос SPEED. Чтобы прекратить рассылку, STOP.

Можно в качестве источника данных использовать не только базу, но и файл, выдавая его построчно или
какой-то хитрый генератор:

	./cursord -t generator -a "name=fibbonachi,init=8"

В ответ на запросы курсор будет возвращать 13, 21, 34, ...

Короче говоря, готовый источник задач для организации распределённой обработки.

Клиент и библиотека
===================

Разработан клиент, позволяющий работать с курсором из командной строки и библиотека, упрощающая
разработку.

Сборка
======

Проект собирается с использованием системы сборки cmake.

Документация
============

doxygen документация расположена в исходниках (не в заголовочных файлах, а в исходниках).

Тестирование
============

Тесты реализованы с использованием библиотеки gtest.

Поддрежка ОС
============

Задуман как кросс-платформенный. На данном этапе пишется и тестируется под Linux.

History
=======

2012-11-03
----------

Cursord 2.0: переписано с нуля

2012-11-01
----------

Курсор работает по протоколу UDP. В ответ на UDP запрос отсылает UDP ответ. Ввиду отсутствия
гарантии, возможна потеря пакетов. Поддерживаются следующие команды: GET, SPEED, STOP.
Реализованы следующие источники: PostgeSQL БД, файл, генераторы: хост, хост+порт

ROADMAP: Переписать поддержку БД на ODBC (unixODBC), добавить поддержку подключения собственного
	 генератора. Реализовать клиентские библиотеки для различных языков программирования. Убрать
	 boost.
