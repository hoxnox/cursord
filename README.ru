<!-- @author     Merder Kim <hoxnox@gmail.com> 
<!-- @date       2012-06-01 12:32:54 -->
<!-- @copyright  Merder Kim  -->
<!-- Проект распространяется под лицензией BSD -->

О проекте
=========

_Cursord_ представляет собой сервер, последовательно выдающий данные из какого-либо *источника* в
ответ на запросы клиентов.

Источником может выступать файл, запрос к базе данных или какой-то специфичный генератор.

Сервер разработан с целью упрощения оганизации распределённой обработки и чаще всего выступает в
качестве источника задач. Если говорить в рамках модели Consumer-Producer, cursord - это Producer с
встроенной очередью сообщений.

Инструмент простой и понятный.

Пример использования:

Допустим имеется БД в которой хранятся условия для решения задач. Запускаем
курсор следующим образом:

	./cursord -i"username='admin' dbname='data' password='mypass'" "SELECT some_data,
	some_addition_data FROM one_table, second_table WHERE some complex expression"

Теперь у нас имеется сервис, который по запросу `GET` выдаст *очередную* строку, соответствующую
запросу, содержащую условия для решения задачи. Таким образом мы можем запустить N отдельных процессов,
получающих условия и решающих задачи. Как следствие мы может управлять процессом решения задач и
получать данные об общем ходе решения. Рассмотрим глупый, но понятный пример. Допустим имеется
таблица имен и адресов пользователей:

	MAILS

	username mail
	======== ================
	John     john@example.com
	Peter    peter@example.com
	Harry    harry@example.com
	Thomas   thomas@example.com

Мы бы хотели запустить 3 машины, которые посылали бы "Hello, %username%!" каждому пользователю.
Причём с минуты на минуту у нас появиться еще некоторое количество серверов, которые можно будет
подключить к этому процессу. Все просто, запускаем курсор на какой-то машине

	./cursord --credentials="~/.credentials" "SELECT username, mail FROM mails"

А на каждом из серверов запускаем примерно такую программу:

	cursor_host = connect(cursor-host.com);
	response = cursor_host.get();
	data = split(response, 0x1E);
	sendmail(data[0], "Hello, " + data[1]+ "!");

Чтобы проверить скорость рассылки, посылаем курсору запрос SPEED. Чтобы прекратить рассылку, STOP.

Можно в качестве источника данных использовать не только базу, но и файл, выдавая его построчно или
какой-то хитрый генератор:

	./cursor -g fibonachi 8

В ответ на запросы курсор будет возвращать 13, 21, 34, ...

Короче говоря, готовый источник задач для организации распределённой обработки.

Сборка
======

Проект собирается с использованием системы сборки cmake.

Документация
============

doxygen документация расположена в исходниках (не в заголовочных файлах, а в исходниках).

Тестирование
============

Тесты реализованы с использованием библиотеки gtest.

Поддрежка ОС
============

Задуман как кросс-платформенный. На данном этапе пишется и тестируется под Linux.

History
=======

2012-11-01
----------

Курсор работает по протоколу UDP. В ответ на UDP запрос отсылает UDP ответ. Ввиду отсутствия
гарантии, возможна потеря пакетов. Поддерживаются следующие команды: GET, SPEED, STOP.
Реализованы следующие источники: PostgeSQL БД, файл, генераторы: хост, хост+порт
ROADMAP: Переписать поддержку БД на ODBC (unixODBC), добавить поддержку подключения собственного
	 генератора. Реализовать клиентские библиотеки для различных языков программирования. Убрать
	 boost.
